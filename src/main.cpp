#include "precomp.hpp"

#include "Context.hpp"
#include "Exceptions.hpp"
#include "FileParser.hpp"
#include "FileQueue.hpp"
#include "ProcessorThread.hpp"

// Prototype for the function below so we can declare ctxt with the other static variables.
// Slightly kludgy, I know.
void queueCallback(const FileQueue&);

namespace { // Ensure these variables are accessible only within this file.
	bool threadsStarted = false;
	std::vector<std::unique_ptr<ProcessorThread>> auxThreads;
	Context ctxt(&queueCallback);
}

void queueCallback(const FileQueue&)
{
	if (threadsStarted)
		return;

	unsigned int numThreads = std::max(2u, std::thread::hardware_concurrency());

	if (ctxt.verbose)
		printf("Processing multiple files. Starting up %u additional threads.\n", numThreads);

	for (unsigned int n = 0; n < numThreads; ++n)
		auxThreads.emplace_back(new ProcessorThread(ctxt));

	threadsStarted = true;
}

int main(int argc, char** argv) {
	TCLAP::SwitchArg verbFlag("v", "verbose", "Print additional output");
	TCLAP::SwitchArg keepFlag("k", "keep-tex",
	                          "Don't delete the LaTeX files generated by SemTeX after LaTeX has run");
	// -E matches gcc
	TCLAP::SwitchArg preOnlyFlag("E", "preprocess-only",
	                             "Just process files and output LaTeX ones instead of running LaTeX. Implies -k");
	TCLAP::ValueArg<std::string> programArg("p", "program", "The LaTeX program to use. Defaults to pdflatex",
	                                        false, "pdflatex", "LaTeX program");
	TCLAP::UnlabeledValueArg<std::string> fileArg("file", "Base SemTeX file", true, "",  "file");

	TCLAP::CmdLine cmd("SemTeX - Streamlined LaTeX", ' ', "alpha");
	cmd.add(verbFlag);
	cmd.add(keepFlag);
	cmd.add(preOnlyFlag);
	cmd.add(programArg);
	cmd.add(fileArg);

	cmd.parse(argc, argv);

	if (preOnlyFlag.getValue() && programArg.isSet()) {
		fprintf(stderr, "Providing a LaTeX program to run with -p or --program AND\n"
		        "instructing SemTeX not to run said program  with -E or --preprocess-only makes no sense.\n");
		exit(1);
	}

	const std::string& latexProgram = programArg.getValue();

	ctxt.verbose = verbFlag.getValue();

	if (ctxt.verbose)
		printf("Running SemTex - Streamlined LaTeX\n");

	try {
		processFile(fileArg.getValue(), ctxt);
	}
	catch (const Exceptions::Exception& ex) {
		ctxt.error = true;
		fprintf(stderr, "%s\n", ex.message.c_str());
	}
	catch (const std::exception& ex) {
		ctxt.error = true;
		fprintf(stderr, "Unexpected fatal error: %s\n", ex.what());
	}
	catch (...) {
		ctxt.error = true;
		fprintf(stderr, "Unexpected fatal error");
	}

	if (threadsStarted) {
		// Wait for the threads to finish doing their thing
		// See FileQueue::setDequeueEnabled for an explanation on why we are disabling dequeuing here
		while (true) {
			ctxt.queue.setDequeueEnabled(false);
			bool done = std::none_of(auxThreads.begin(), auxThreads.end(),
									 [](const std::unique_ptr<ProcessorThread>& pt) { return pt->isBusy(); } );
			done = done && (ctxt.queue.empty() || ctxt.error);
			ctxt.queue.setDequeueEnabled(true);
			if (done)
				break;
			std::this_thread::sleep_for(ProcessorThread::dequeueTimeout / 2);
		}

		for (auto& thread : auxThreads)
			thread->beginExit();
	}

	if (!ctxt.error) {
		if (!preOnlyFlag.getValue()) {
			if (ctxt.verbose)
				printf("Running %s...\n", latexProgram.c_str());

			//! \todo Move this into a function? This is the second place we use it
			boost::regex fext(R"regex((stex|sex)$)regex", boost::regex::optimize);
			const std::string texname = boost::regex_replace(fileArg.getValue(), fext, "tex");

			fflush(stdout); // Make sure everything prints before LaTeX does

			// TODO: handle pdflatex I/O instead of just calling it
			system((latexProgram + " " + texname).c_str());

			if (ctxt.verbose)
				printf("%s exited.\n", latexProgram.c_str());
		}
	}
	else
	{
		if (ctxt.verbose)
			printf("Skipping %s due to errors\n", latexProgram.c_str());
	}

	if (!keepFlag.getValue() && !preOnlyFlag.getValue()) {
		std::lock_guard<std::mutex> genLock(ctxt.generatedFilesMutex);
		for (const std::string& f : ctxt.generatedFiles) {
			if (ctxt.verbose)
				printf("Removing intermediate LaTeX file %s\n", f.c_str());

			boost::filesystem::remove(f);
		}
	}

	if (threadsStarted) {
		for (auto& thread : auxThreads)
			thread->join();
	}
	return 0;
}
